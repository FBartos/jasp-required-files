<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Reconstruct a reference grid with a new transformation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for regrid {emmeans}"><tr><td>regrid {emmeans}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Reconstruct a reference grid with a new transformation</h2>

<h3>Description</h3>

<p>The typical use of this function is to cause EMMs to be computed on
a different scale, e.g., the back-transformed scale rather than the 
linear-predictor scale. In other words, if you want back-transformed 
results, do you want to average and then back-transform, or 
back-transform and then average?
</p>


<h3>Usage</h3>

<pre>
regrid(object, transform = c("response", "mu", "unlink", "log", "none"),
  inv.log.lbl = "response", predict.type)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>object</code></td>
<td>
<p>An object of class <code>emmGrid</code></p>
</td></tr>
<tr valign="top"><td><code>transform</code></td>
<td>
<p>Character or logical value. If <code>"response"</code> or
<code>"mu"</code>, the inverse transformation is applied to the estimates in the
grid (but if there is both a link function and a response transformation,
<code>"mu"</code> back-transforms only the link part); if <code>"log"</code>, the
results are formulated as if the response had been <code>log</code>-transformed;
if <code>"none"</code>, predictions thereof are on the same scale as in 
<code>object</code>, and any internal transformation information is preserved. 
For compatibility with past versions, <code>transform</code> may also be logical;
<code>TRUE</code> is taken as <code>"response"</code>, and <code>FALSE</code> as 
<code>"none"</code>.</p>
</td></tr>
<tr valign="top"><td><code>inv.log.lbl</code></td>
<td>
<p>Character value. This applies only when <code>transform =
"log"</code>, and is used to label the predictions if subsequently summarized
with <code>type = "response"</code>.</p>
</td></tr>
<tr valign="top"><td><code>predict.type</code></td>
<td>
<p>Character value. If provided, the returned object is
updated with the given type, e.g., <code>"response"</code>. 
See <code><a href="update.emmGrid.html">update.emmGrid</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>regrid</code> function reparameterizes an existing <code>ref.grid</code> so
that its <code>linfct</code> slot is the identity matrix and its <code>bhat</code> slot
consists of the estimates at the grid points. If <code>transform</code> is
<code>TRUE</code>, the inverse transform is applied to the estimates. Outwardly,
when <code>transform = "response"</code>, the result of <code><a href="summary.emmGrid.html">summary.emmGrid</a></code>
after applying <code>regrid</code> is identical to the summary of the original
object using <span class="samp">type="response"</span>. But subsequent EMMs or
contrasts will be conducted on the new scale &ndash; which is
the reason this function exists.
</p>
<p>In cases where the
degrees of freedom depended on the linear function being estimated, the d.f.
from the reference grid are saved, and a kind of &ldquo;containment&rdquo; method
is substituted in the returned object whereby the calculated d.f. for a new
linear function will be the minimum d.f. among those having nonzero
coefficients. This is kind of an <em>ad hoc</em> method, and it can
over-estimate the degrees of freedom in some cases.
</p>


<h3>Value</h3>

<p>An <code>emmGrid</code> object with the requested changes
</p>


<h3>Note</h3>

<p>Another way to use <code>regrid</code> is to supply a <code>transform</code> 
argument to <code><a href="ref_grid.html">ref_grid</a></code> (either directly of indirectly via
<code><a href="emmeans.html">emmeans</a></code>). This is often a simpler approach if the reference
grid has not already been constructed.
</p>


<h3>Examples</h3>

<pre>
pigs.lm &lt;- lm(log(conc) ~ source + factor(percent), data = pigs)

# This will yield EMMs as GEOMETRIC means of concentrations:
emmeans(pigs.lm, "source", type = "response")
# NOTE: pairs() of the above will be RATIOS of these results

# This will yield EMMs as ARITHMETIC means of concentrations:
emmeans(regrid(ref_grid(pigs.lm, transform = "response")), "source")
# Same thing, made simpler:
emmeans(pigs.lm, "source", transform = "response")
# NOTE: pairs() of the above will be DIFFERENCES of these results
</pre>

<hr /><div style="text-align: center;">[Package <em>emmeans</em> version 1.3.2 <a href="00Index.html">Index</a>]</div>
</body></html>
